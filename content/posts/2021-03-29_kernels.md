---
title: "Kernels... real time"
date: 2021-03-29T21:00:00+01:00
location: "France"
---

In image processing, a **kernel** (convolution matrix, or mask) is a small matrix used to apply effects to an image, such as blurring, sharpening or outlining. These effects are accomplished by performing a convolution between a kernel and an image.

A convolution can be defined by the following formula:

$ g(x, y)=\omega * f(x, y)=\sum_{d x=-a}^{a} \sum_{d y=-b}^{b} \omega(d x, d y) f(x+d x, y+d y) $

where $ g(x, y)$  is something

<pre id="fragment_shader">
precision mediump float;
uniform sampler2D image;
uniform vec2 resolution;
uniform mat3 kernel;
varying vec2 uv;

void main(){
    vec2 cellSize = 1.0 / resolution;
    for(int i=-1; i<=1; i++){
        for(int j=-1; j<=1; j++){
            vec2 vec = cellSize * vec2(float(i), float(j));
            gl_FragColor += 
                texture2D(image, uv + vec) *
                kernel[i][j];
        }
    }
    gl_FragColor[3] = 1.0; //alpha correction
}
</pre>

<video src="http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" crossOrigin="anonymous" controls width=100% id="video" muted autoplay>
	Your browser does not support the video tag.
</video><br/>
<canvas id="canvas" width="500" height="300"></canvas><br/>

<div class="row">
    <form name="kernelform" class="col">
        <input type="radio" name="kernel" value="[0,0,0,0,1,0,0,0,0]"> Identity</input><br/>
        <input type="radio" name="kernel" value="[1,1,1,1,-8,-1,1,1,1]" checked> Laplacian Edge Detection</input><br/>
        <input type="radio" name="kernel" value="[0.0625,0.125,0.0625,0.125,0.250,0.125,0.0625,0.125,0.0625]"> Gaussian Blur</input><br/>
        <input type="radio" name="kernel" value="[0.111,0.111,0.111,0.111,0.111,0.111,0.111,0.111,0.111]"> Box Blur</input><br/>
        <input type="radio" name="kernel" value="[0,-1,0,-1,5,-1,0,-1,0]"> Sharpen</input><br/>
        <input type="radio" name="kernel" value="[-1,-1,-1,-1,9,-1,-1,-1,-1]"> Unsharpen</input><br/>
    </form>
    <table id="kernelviz" class="matrix col">
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>-8</td>
            <td>1</td>
        </tr>
        <tr>
            <td>1</td>
            <td>1</td>
            <td>1</td>
        </tr>
    </table>
</div>

<script>
	const canvas = document.getElementById("canvas");
    const video = document.getElementById("video");
    const kernelform = document.forms.kernelform;
    const kernelviz = document.getElementById("kernelviz");

    // matrix update on radio change
    const chunk = (array, size) => Array.from({length: Math.ceil(array.length / size)}, (value, index) => array.slice(index * size, index * size + size));
    document.addEventListener("input", function(e) {
        if(e.target.getAttribute("name") == "kernel") {
            let value = eval(e.target.value);
            value = value.map(e => "<td>" + e + "</td>");
            value = chunk(value,3);
            value = value.map(e => "<tr>" + e.join("") + "</tr>").join("");
            console.log(value);
            kernelviz.innerHTML = value;
        }
    });

    video.oncanplay = function() {
        canvasResize();
        loadShaders();
    };

    function canvasResize() {
        let videoComputedStyle = getComputedStyle(video);
        canvas.width = parseFloat(videoComputedStyle.width); 
        canvas.height = parseFloat(videoComputedStyle.height);
    }
    
    function loadShaders() {
        let gl = null;
        let gl_contextAttributes = { antialias:false };
        for (let i=0; i<4; i++) {
            gl = canvas.getContext(["webgl","experimental-webgl","moz-webgl","webkit-3d"][i], gl_contextAttributes)
            if (gl)
                break;
        }
        
        let vs = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vs, `
            attribute vec2 vx;
            varying vec2 uv;
            
            void main(){
                gl_Position = vec4(vx.x*2.0-1.0, 1.0-vx.y*2.0, 0, 1);
                uv = vx;
            }
        `);
        gl.compileShader(vs);

        let ps = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(ps, document.getElementById("fragment_shader").innerText);
        gl.compileShader(ps);

        let shader  = gl.createProgram();
        gl.attachShader(shader, vs);
        gl.attachShader(shader, ps);
        gl.linkProgram(shader);
        gl.useProgram(shader);

        // basic attributes
        let vx_ptr = gl.getAttribLocation(shader, "vx");
        gl.enableVertexAttribArray(vx_ptr);
        let vx = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vx);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0,0, 1,0, 1,1, 0,1]), gl.STATIC_DRAW);
        let ix = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ix);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);
        let tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T,     gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S,     gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        
        // custom attributes
        let resolution = gl.getUniformLocation(shader,"resolution");
        gl.uniform2fv(resolution, [canvas.width, canvas.height]);  
        let kernel = gl.getUniformLocation(shader,"kernel");

        function frameloop() {
            // pass kernel
            let selectedKernel = kernelform.querySelector("input[name=kernel]:checked").value;
            gl.uniformMatrix3fv(kernel, false, eval(selectedKernel));

            // basic gl video play
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, video);
            gl.bindBuffer(gl.ARRAY_BUFFER, vx);
            gl.vertexAttribPointer(vx_ptr, 2, gl.FLOAT, false, 0, 0);
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ix);
            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
            window.requestAnimationFrame(frameloop);
        }
        frameloop();
    }
</script>

<style>
.row {
    margin: 20px 0;
}
.col {
    vertical-align: middle;
    display:inline-block;
    margin: 10px;
}
.matrix {
    display:inline-block;
    position: relative;
    margin: 30px;
}
.matrix:before, .matrix:after {
    content: "";
    position: absolute;
    top: 0;
    border: 1px solid #000;
    width: 6px;
    height: 100%;
}
.matrix:before {
    left: -6px;
    border-right: 0px;
}
.matrix:after {
    right: -6px;
    border-left: 0px;
}
.matrix td {
    padding: 5px 15px;    
    text-align: center;
}
</style>